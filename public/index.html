<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Image Protector — Frontend</title>
		<style>
			:root {
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
				font-size: 15px;
				color: #111;
			}
			body {
				margin: 0;
				padding: 24px;
				display: flex;
				justify-content: center;
				background: #f6f7fb;
			}
			main {
				width: 100%;
				max-width: 980px;
				background: #fff;
				border-radius: 10px;
				padding: 20px 24px;
				box-shadow: 0 8px 30px rgba(20, 20, 40, 0.06);
			}
			h1 {
				margin: 0 0 12px;
				font-size: 20px;
			}
			.row {
				display: flex;
				gap: 12px;
				align-items: center;
			}
			label {
				font-weight: 600;
				font-size: 13px;
				margin-bottom: 6px;
				display: block;
			}
			fieldset {
				border: 1px solid #e6e9ef;
				padding: 12px;
				border-radius: 8px;
				margin-bottom: 12px;
			}
			.two-col {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 12px;
			}
			input[type='file'] {
				display: block;
			}
			input[type='url'],
			input[type='text'],
			textarea,
			select {
				width: 100%;
				padding: 8px;
				border: 1px solid #d7dbe8;
				border-radius: 6px;
			}
			textarea {
				resize: vertical;
				min-height: 80px;
			}
			button {
				background: #0b66ff;
				color: #fff;
				border: 0;
				padding: 10px 14px;
				border-radius: 8px;
				font-weight: 600;
				cursor: pointer;
			}
			button[disabled] {
				opacity: 0.5;
				cursor: default;
			}
			.muted {
				color: #6b6f76;
				font-size: 13px;
			}
			.meta-rows {
				display: flex;
				flex-direction: column;
				gap: 6px;
			}
			.meta-row {
				display: flex;
				gap: 8px;
			}
			.meta-row input {
				flex: 1;
			}
			.meta-row button {
				background: #efefef;
				color: #333;
				padding: 6px;
				border-radius: 6px;
				border: 1px solid #ddd;
			}
			#previewWrap {
				display: flex;
				gap: 12px;
				flex-wrap: wrap;
				margin-top: 8px;
			}
			.preview {
				width: 120px;
				height: 120px;
				border-radius: 6px;
				border: 1px solid #e6e9ef;
				display: flex;
				align-items: center;
				justify-content: center;
				background: #fafbff;
				overflow: hidden;
			}
			.small {
				font-size: 12px;
				color: #666;
			}
			#result {
				margin-top: 12px;
			}
			.controls {
				display: flex;
				gap: 8px;
				align-items: center;
			}
			.input-inline {
				display: flex;
				gap: 8px;
				align-items: center;
			}
			.opt {
				display: flex;
				gap: 8px;
				align-items: center;
				margin-top: 6px;
			}
			.help {
				font-size: 12px;
				color: #666;
				margin-top: 6px;
			}
		</style>
	</head>
	<body>
		<main>
			<h1>Image Protector</h1>

			<form id="uploadForm" autocomplete="off" novalidate>
				<fieldset>
					<legend class="muted">Main image</legend>
					<div class="two-col">
						<div>
							<label>Main image (file)</label>
							<input id="mainFile" name="main_file" type="file" accept="image/*" />
							<div class="help">Supported: JPG/JPEG, PNG, WEBP, HEIC, SVG. You may also provide a public URL below.</div>
						</div>
						<div>
							<label>Main image (public URL)</label>
							<input id="mainUrl" name="main_url" type="url" placeholder="https://example.com/image.jpg" />
						</div>
					</div>
				</fieldset>

				<fieldset>
					<legend class="muted">Watermark (optional)</legend>
					<div class="two-col">
						<div>
							<label>Watermark (file)</label>
							<input id="wmFile" name="watermark_file" type="file" accept="image/*" />
						</div>
						<div>
							<label>Watermark (public URL)</label>
							<input id="wmUrl" name="watermark_url" type="url" placeholder="https://example.com/wm.png" />
						</div>
					</div>

					<div class="opt">
						<div style="min-width: 220px">
							<label>Watermark size</label>
							<select id="wmSize">
								<option value="10p">10% width</option>
								<option value="15p">15% width</option>
								<option value="20p" selected>20% width</option>
								<option value="30p">30% width</option>
							</select>
						</div>
						<div style="min-width: 160px">
							<label>Watermark opacity</label>
							<select id="wmOpacity">
								<option value="30">30%</option>
								<option value="45">45%</option>
								<option value="60" selected>60%</option>
								<option value="80">80%</option>
							</select>
						</div>
						<div style="min-width: 160px">
							<label>Gravity</label>
							<select id="wmGravity">
								<option value="center" selected>Center</option>
								<option value="northwest">Top-left</option>
								<option value="northeast">Top-right</option>
								<option value="southwest">Bottom-left</option>
								<option value="southeast">Bottom-right</option>
							</select>
						</div>
					</div>
				</fieldset>

				<fieldset>
					<legend class="muted">Metadata to embed</legend>

					<div style="display: flex; gap: 12px; align-items: flex-start">
						<div style="flex: 1">
							<label>Common fields</label>
							<input id="metaAuthor" type="text" placeholder="Author / Creator" />
							<div style="height: 8px"></div>
							<input id="metaDesc" type="text" placeholder="Description / ImageDescription" />
							<div style="height: 8px"></div>
							<input id="metaSource" type="text" placeholder="Source / Website" />
						</div>

						<div style="flex: 1">
							<label>Custom key/value pairs</label>
							<div class="meta-rows" id="metaRows"></div>
							<div style="margin-top: 8px">
								<button type="button" id="addMeta">Add pair</button>
							</div>
						</div>
					</div>

					<div style="margin-top: 10px">
						<label>Raw metadata JSON (optional override)</label>
						<textarea id="metadataJson" name="metadata_json" placeholder='{"Author":"Alice","Source":"example.com"}'></textarea>
					</div>
				</fieldset>

				<div class="row" style="justify-content: space-between; align-items: center">
					<div class="muted small">
						Uploads are sent to the worker at <code>/process</code>. The worker embeds EXIF / PNG text / SVG metadata and optionally applies
						a watermark.
					</div>
					<div style="display: flex; gap: 8px; align-items: center">
						<button id="submitBtn" type="submit">Protect & Download</button>
					</div>
				</div>
			</form>

			<div id="result"></div>

			<section id="previewArea" style="margin-top: 16px">
				<label>Previews</label>
				<div id="previewWrap" aria-live="polite"></div>
			</section>
		</main>

		<script>
			// Minimal, dependency-free frontend.
			(function () {
				const form = document.getElementById('uploadForm');
				const mainFile = document.getElementById('mainFile');
				const mainUrl = document.getElementById('mainUrl');
				const wmFile = document.getElementById('wmFile');
				const wmUrl = document.getElementById('wmUrl');
				const metadataJson = document.getElementById('metadataJson');
				const metaRows = document.getElementById('metaRows');
				const addMeta = document.getElementById('addMeta');
				const metaAuthor = document.getElementById('metaAuthor');
				const metaDesc = document.getElementById('metaDesc');
				const metaSource = document.getElementById('metaSource');
				const previewWrap = document.getElementById('previewWrap');
				const submitBtn = document.getElementById('submitBtn');
				const result = document.getElementById('result');
				const wmSize = document.getElementById('wmSize');
				const wmOpacity = document.getElementById('wmOpacity');
				const wmGravity = document.getElementById('wmGravity');

				function createMetaRow(key = '', value = '') {
					const wrap = document.createElement('div');
					wrap.className = 'meta-row';
					const k = document.createElement('input');
					k.type = 'text';
					k.placeholder = 'key';
					k.value = key;
					const v = document.createElement('input');
					v.type = 'text';
					v.placeholder = 'value';
					v.value = value;
					const rm = document.createElement('button');
					rm.type = 'button';
					rm.textContent = 'remove';
					rm.addEventListener('click', () => wrap.remove());
					wrap.appendChild(k);
					wrap.appendChild(v);
					wrap.appendChild(rm);
					metaRows.appendChild(wrap);
					return wrap;
				}

				addMeta.addEventListener('click', () => createMetaRow());

				// initial one
				createMetaRow('Copyright', '');

				function clearPreviews() {
					previewWrap.innerHTML = '';
				}

				function addPreview(fileOrUrl, label) {
					const box = document.createElement('div');
					box.className = 'preview';
					if (fileOrUrl instanceof File) {
						const reader = new FileReader();
						reader.onload = () => {
							if (fileOrUrl.type && fileOrUrl.type.startsWith('image')) {
								const img = document.createElement('img');
								img.style.maxWidth = '100%';
								img.style.maxHeight = '100%';
								img.src = reader.result;
								box.appendChild(img);
							} else {
								box.textContent = 'file';
							}
						};
						reader.readAsDataURL(fileOrUrl);
					} else if (typeof fileOrUrl === 'string' && fileOrUrl.trim() !== '') {
						const img = document.createElement('img');
						img.style.maxWidth = '100%';
						img.style.maxHeight = '100%';
						img.src = fileOrUrl;
						img.onerror = () => {
							box.textContent = 'preview failed';
						};
						box.appendChild(img);
					} else {
						box.textContent = label || '';
					}
					previewWrap.appendChild(box);
				}

				function refreshPreviews() {
					clearPreviews();
					if (mainFile.files && mainFile.files[0]) addPreview(mainFile.files[0], 'main');
					else if (mainUrl.value) addPreview(mainUrl.value, 'main-url');

					if (wmFile.files && wmFile.files[0]) addPreview(wmFile.files[0], 'wm');
					else if (wmUrl.value) addPreview(wmUrl.value, 'wm-url');
				}

				mainFile.addEventListener('change', refreshPreviews);
				mainUrl.addEventListener('input', refreshPreviews);
				wmFile.addEventListener('change', refreshPreviews);
				wmUrl.addEventListener('input', refreshPreviews);

				function collectMetadata() {
					// If raw JSON provided and valid, use it (worker will prefer metadata_json)
					const raw = metadataJson.value && metadataJson.value.trim();
					if (raw) {
						try {
							const parsed = JSON.parse(raw);
							if (parsed && typeof parsed === 'object') return parsed;
						} catch (e) {
							// fall through to constructing from fields
						}
					}
					const out = {};
					if (metaAuthor.value.trim()) out.Author = metaAuthor.value.trim();
					if (metaDesc.value.trim()) out.Description = metaDesc.value.trim();
					if (metaSource.value.trim()) out.Source = metaSource.value.trim();
					const rows = metaRows.querySelectorAll('.meta-row');
					rows.forEach((r) => {
						const k = r.children[0].value.trim();
						const v = r.children[1].value.trim();
						if (k) out[k] = v;
					});
					return out;
				}

				async function postProcessResponse(res) {
					// If response is an image blob, create download link
					const ct = res.headers.get('content-type') || '';
					if (!res.ok) {
						let err;
						try {
							err = await res.json();
						} catch (_) {
							err = { error: res.statusText };
						}
						result.textContent = 'Error: ' + (err?.error || JSON.stringify(err));
						return;
					}
					const blob = await res.blob();
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					const disp = res.headers.get('content-disposition') || '';
					// try to extract filename
					let fname = 'protected-image';
					const m = disp.match(/filename\\*=UTF-8''([^;\\n]+)/i) || disp.match(/filename=\"?([^\";\\n]+)\"?/i);
					if (m && m[1]) fname = decodeURIComponent(m[1].replace(/\\s/g, '_'));
					a.download = fname;
					a.textContent = 'Download protected image (' + (ct.split(';')[0] || 'image') + ')';
					a.style.display = 'inline-block';
					a.style.marginTop = '8px';
					result.innerHTML = '';
					result.appendChild(a);
				}

				form.addEventListener('submit', async (ev) => {
					ev.preventDefault();
					result.textContent = 'Processing…';
					submitBtn.disabled = true;
					result.innerHTML = '';

					const fd = new FormData();

					// Prefer file if provided, otherwise url
					if (mainFile.files && mainFile.files[0]) fd.append('main_file', mainFile.files[0]);
					else if (mainUrl.value.trim()) fd.append('main_url', mainUrl.value.trim());

					if (wmFile.files && wmFile.files[0]) fd.append('watermark_file', wmFile.files[0]);
					else if (wmUrl.value.trim()) fd.append('watermark_url', wmUrl.value.trim());

					// Add watermark transform options as meta fields the worker will translate to cf.image.draw
					// We'll include them as top-level form fields to be safe (worker currently reads wm options from form or DOM)
					fd.append('wm_size', wmSize.value);
					fd.append('wm_opacity', wmOpacity.value);
					fd.append('wm_gravity', wmGravity.value);

					// Metadata: send metadata_json as worker prefers that
					const meta = collectMetadata();
					fd.append('metadata_json', JSON.stringify(meta));

					try {
						const res = await fetch('/process', { method: 'POST', body: fd });
						await postProcessResponse(res);
					} catch (err) {
						result.textContent = 'Network or server error';
					} finally {
						submitBtn.disabled = false;
					}
				});

				// small UX niceties: allow Enter to submit when focus in metadata JSON
				metadataJson.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
						submitBtn.click();
					}
				});

				// initial previews
				refreshPreviews();
			})();
		</script>
	</body>
</html>
